#!/usr/bin/env python3
import tkinter as tk
from tkinter import ttk, messagebox
import pulsectl
import time
import logging
import math
import json
import threading
import queue
from pathlib import Path
from typing import Dict, Optional, List
from dataclasses import dataclass
import sys

@dataclass
class Config:
    max_db: float = -10.0
    check_interval: float = 0.1
    
    @classmethod
    def load(cls) -> 'Config':
        config_path = Path.home() / '.config' / 'vlmt' / 'config.json'
        if config_path.exists():
            with open(config_path) as f:
                data = json.load(f)
                return cls(**data)
        return cls()
    
    def save(self) -> None:
        config_path = Path.home() / '.config' / 'vlmt' / 'config.json'
        config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(config_path, 'w') as f:
            json.dump(self.__dict__, f, indent=2)

class PulseAudioManager:
    def __init__(self):
        self._local = threading.local()
        
    def _get_pulse(self):
        if not hasattr(self._local, 'pulse'):
            self._local.pulse = pulsectl.Pulse('volume-limiter-gui')
        return self._local.pulse
    
    def close(self):
        if hasattr(self._local, 'pulse'):
            self._local.pulse.close()
            del self._local.pulse

    def get_stream_volume_db(self, stream) -> float:
        volume = stream.volume.value_flat
        return float('-inf') if volume <= 0 else 20 * math.log10(volume)

    def set_stream_volume_db(self, stream, db: float) -> None:
        linear_volume = 10 ** (db / 20)
        pulse = self._get_pulse()
        pulse.volume_set_all_chans(stream, linear_volume)

    def get_streams(self):
        pulse = self._get_pulse()
        return pulse.sink_input_list()

class VolumeLimiterGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Volume Limiter")
        self.root.geometry("600x400")
        
        # Load config
        self.config = Config.load()
        
        # Initialize PulseAudio manager
        self.pulse_manager = PulseAudioManager()
        
        # Setup variables
        self.is_running = False
        self.limiter_thread = None
        self.update_queue = queue.Queue()
        
        self.create_gui()
        self.update_streams()
        
        # Start periodic updates
        self.root.after(1000, self.periodic_update)
        self.root.after(100, self.check_queue)

    def create_gui(self):
        # Create main frame with padding
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configuration section
        config_frame = ttk.LabelFrame(main_frame, text="Configuration", padding="5")
        config_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        ttk.Label(config_frame, text="Max Volume (dB):").grid(row=0, column=0, padx=5)
        self.max_db_var = tk.StringVar(value=str(self.config.max_db))
        max_db_entry = ttk.Entry(config_frame, textvariable=self.max_db_var, width=10)
        max_db_entry.grid(row=0, column=1, padx=5)
        
        ttk.Button(config_frame, text="Save", command=self.save_config).grid(row=0, column=2, padx=5)
        
        # Control section
        control_frame = ttk.Frame(main_frame)
        control_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        self.status_var = tk.StringVar(value="Status: Stopped")
        ttk.Label(control_frame, textvariable=self.status_var).grid(row=0, column=0, padx=5)
        
        self.toggle_button = ttk.Button(control_frame, text="Start", command=self.toggle_limiter)
        self.toggle_button.grid(row=0, column=1, padx=5)
        
        # Streams section
        streams_frame = ttk.LabelFrame(main_frame, text="Active Streams", padding="5")
        streams_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Create Treeview for streams
        self.tree = ttk.Treeview(streams_frame, columns=("id", "name", "volume", "media"), show="headings")
        self.tree.heading("id", text="ID")
        self.tree.heading("name", text="Application")
        self.tree.heading("volume", text="Volume (dB)")
        self.tree.heading("media", text="Media Name")
        
        self.tree.column("id", width=50)
        self.tree.column("name", width=150)
        self.tree.column("volume", width=100)
        self.tree.column("media", width=200)
        
        scrollbar = ttk.Scrollbar(streams_frame, orient=tk.VERTICAL, command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        
        self.tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # Configure grid weights
        streams_frame.columnconfigure(0, weight=1)
        streams_frame.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(2, weight=1)
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)

    def save_config(self):
        try:
            new_db = float(self.max_db_var.get())
            self.config.max_db = new_db
            self.config.save()
            messagebox.showinfo("Success", "Configuration saved successfully!")
        except ValueError:
            messagebox.showerror("Error", "Please enter a valid number for maximum dB")
            self.max_db_var.set(str(self.config.max_db))

    def toggle_limiter(self):
        if not self.is_running:
            self.start_limiter()
        else:
            self.stop_limiter()

    def start_limiter(self):
        self.is_running = True
        self.toggle_button.configure(text="Stop")
        self.status_var.set("Status: Running")
        
        self.limiter_thread = threading.Thread(target=self.limiter_loop, daemon=True)
        self.limiter_thread.start()

    def stop_limiter(self):
        self.is_running = False
        self.toggle_button.configure(text="Start")
        self.status_var.set("Status: Stopped")

    def update_streams(self):
        try:
            # Clear current items
            for item in self.tree.get_children():
                self.tree.delete(item)
            
            # Add current streams
            streams = self.pulse_manager.get_streams()
            for stream in streams:
                db = self.pulse_manager.get_stream_volume_db(stream)
                self.tree.insert("", tk.END, values=(
                    stream.index,
                    stream.name,
                    f"{db:.1f}",
                    stream.proplist.get('media.name', 'N/A')
                ))
        except Exception as e:
            self.status_var.set(f"Status: Error updating streams")

    def limiter_loop(self):
        local_pulse_manager = PulseAudioManager()
        
        while self.is_running:
            try:
                sink_inputs = local_pulse_manager.get_streams()
                
                for stream in sink_inputs:
                    current_db = local_pulse_manager.get_stream_volume_db(stream)
                    
                    if current_db > self.config.max_db:
                        local_pulse_manager.set_stream_volume_db(stream, self.config.max_db)
                        self.update_queue.put(True)  # Signal for GUI update
                
                time.sleep(self.config.check_interval)
            except Exception as e:
                print(f"Error in limiter loop: {e}")
                time.sleep(1)  # Avoid tight loop on error
                
        local_pulse_manager.close()

    def check_queue(self):
        try:
            while True:
                self.update_queue.get_nowait()
                self.update_streams()
        except queue.Empty:
            pass
        finally:
            self.root.after(100, self.check_queue)

    def periodic_update(self):
        self.update_streams()
        self.root.after(1000, self.periodic_update)

    def on_closing(self):
        self.stop_limiter()
        self.pulse_manager.close()
        self.root.destroy()

def main():
    try:
        root = tk.Tk()
        app = VolumeLimiterGUI(root)
        root.protocol("WM_DELETE_WINDOW", app.on_closing)
        root.mainloop()
    except Exception as e:
        print(f"Fatal error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()